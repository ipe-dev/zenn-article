---
title: "【Go】EchoとNextjsを使ってCORSを学んでみた"
emoji: "😎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Golang, CORS]
published: false
---
# これは何
Goのhttprouterの使い方を見ていたら、`GlobalOPTIONS`という変数を使ってpreflight requestに対してヘッダをつけられることを知りました。
これを使ってCORSに関する理解を深めたいなーと思ったので記事にします。
# この記事のゴール
- echoフレームワークを使ってCORSの目的と仕組みを（ざっくり）理解する
# 結論
# CORSについて
CORSはオリジン間リソース共有（Cross Origin Resource Shearing）の頭文字をとったものです。
異なるオリジンにあるリソースにアクセスする際に、アクセスを許可するか否かを決める仕組みです。
## オリジンとは
そもそもオリジンとは何なのかというと
- スキーム
- ドメイン
- ポート

の3つを合わせたものをオリジンといいます。
例えば、`http://example.com:80/hoge/fuga.html`というURLがあったとすると。
httpが`スキーム`、example.comが`ドメイン`、80が`ポート`です。
`hoge/fuga.html`の部分はパスなので関係ないです。
## CORSを使う目的
CORSを使う目的は、異なるオリジンにあるリソースにアクセスを許可することです。
なぜわざわざ許可するのかというと、リソースをFetchする時には`同一オリジンポリシー`というポリシーがあるためです。
### 同一オリジンポリシー
同一オリジンポリシーは、そのままですが、同じオリジンからのアクセスのみを許可する仕組みです。
デフォルトでこの状態になっているため、異なるオリジンからのリクエストを許可したい場合にはCORSを使う必要があります。
## プリフライトリクエスト
リクエストの種類によっては、リクエストを送信する前に`プリフライトリクエスト`というリクエストがブラウザによって自動的に送信されることがあります。
プリフライトリクエストは`OPTIONS`メソッドを使ったリクエストで、サーバーがCORSに対応しているかどうかを確認します。
また、[単純リクエスト](https://developer.mozilla.org/ja/docs/Web/HTTP/CORS#%E5%8D%98%E7%B4%94%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88)と呼ばれるリクエストを送る前にはプリフライトリクエストは送られません。
# 実験してみる
## echo
echoはGoのWebフレームワークです。
基本的な使い方はREADMEを参照してください。
https://github.com/labstack/echo
今回はechoのミドルウェア機能を使ってCORSを実現したいと思います。
https://echo.labstack.com/docs/middleware/cors
## バックエンドの実装
以下がバックエンドの実装例です。
```go
type PostRequest struct {
	Name string `json:"name"`
}

func getHello(c echo.Context) error {
	return c.JSON(http.StatusOK, map[string]string{"message": "get hello world"})
}

func postHello(c echo.Context) error {
	r := new(PostRequest)
	if err := c.Bind(r); err != nil {
		return err
	}
	fmt.Println(r)
	return c.JSON(http.StatusOK, map[string]string{"message": fmt.Sprintf("%s hello world", r.Name)})
}

func main() {
	e := echo.New()
	// ミドルウェアを使ってCORSの設定をする
	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		// http://example.comのオリジンのみを許可
		AllowOrigins: []string{"http://example.com"},
		// Oigin,ContentType,Acceptのヘッダを許可
		AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept},
	}))
	e.GET("/getHello", getHello)
	e.POST("/postHello", postHello)
	e.Logger.Fatal(e.Start(":8090"))
}
```
まず、`getHello`と`postHello`というハンドラを用意しました。
それぞれ、`/getHello`と`/postHello`にGETとPOSTでアクセスしたときのハンドラになっています。
CORSを設定しているのは`Use`というメソッドを使っている部分です。
`http://example.com`というオリジンのみを許可しています。
また、`e.Use(middleware.CORS())`とするとecho側で用意されたデフォルトの設定となり、どんなオリジンからのアクセスも許可するようになります。
## フロントエンドの実装
続いてフロントエンドの実装例です。
今回はNext.jsの`fetch`を使ってAPIを実行します。
```tsx
const getFromEcho = async () => {
    const response = await fetch("http://localhost:8090/getHello")
    return response 
    
}
const postToEcho = async () => {
    const name = "taro"
    const response = await fetch("http://localhost:8090/postHello", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({ name: name })
    })
    return response
}
const CorsTest = () => {
    const response = getFromEcho()
    
    return (
        <>
            <h1>CORS Test Page</h1>
        </>
    )
}
```
`getFromEcho`と`postToEcho`がそれぞれサーバーへのGETとPOSTに対応しています。
## GET
実際にアクセスし、デベロッパーツールのネットワークを見てみると以下のようなレスポンスが返ってきています。
![](/images/image20240325_1.png)

### リクエストヘッダ
### レスポンスヘッダ